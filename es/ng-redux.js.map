{"version":3,"file":"ng-redux.js","sources":["../src/utils/shallowEqual.js","../src/utils/wrapActionCreators.js","../src/components/connector.js","../src/components/digestMiddleware.js","../src/components/providedStoreMiddleware.js","../src/components/storeWrapper.js","../src/components/ngRedux.js","../src/index.js"],"sourcesContent":[" export default function shallowEqual(objA, objB) {\n   if (objA === objB) {\n     return true;\n   }\n\n   /* $$hashKey is added by angular when using ng-repeat, we ignore that*/\n   var keysA = Object.keys(objA).filter(k => k !== '$$hashKey');\n   var keysB = Object.keys(objB).filter(k => k !== '$$hashKey');\n\n   if (keysA.length !== keysB.length) {\n     return false;\n   }\n\n   // Test for A's keys different from B.\n   var hasOwn = Object.prototype.hasOwnProperty;\n   for (let i = 0; i < keysA.length; i++) {\n     if (!hasOwn.call(objB, keysA[i]) ||\n       objA[keysA[i]] !== objB[keysA[i]]) {\n       return false;\n     }\n   }\n\n   return true;\n }","import { bindActionCreators } from 'redux';\n\nexport default function wrapActionCreators(actionCreators) {\n  return dispatch => bindActionCreators(actionCreators, dispatch);\n}\n","import shallowEqual from '../utils/shallowEqual';\nimport wrapActionCreators from '../utils/wrapActionCreators';\nimport invariant from 'invariant';\n\nimport isPlainObject from 'lodash/isPlainObject';\nimport isFunction from 'lodash/isFunction';\nimport isObject from 'lodash/isObject';\n\nconst assign = Object.assign;\nconst defaultMapStateToTarget = () => ({});\nconst defaultMapDispatchToTarget = dispatch => ({dispatch});\n\nexport default function Connector(store) {\n  return (mapStateToTarget, mapDispatchToTarget) => {\n\n    let finalMapStateToTarget = mapStateToTarget || defaultMapStateToTarget;\n\n    const finalMapDispatchToTarget = isPlainObject(mapDispatchToTarget) ?\n      wrapActionCreators(mapDispatchToTarget) :\n      mapDispatchToTarget || defaultMapDispatchToTarget;\n\n    invariant(\n      isFunction(finalMapStateToTarget),\n      'mapStateToTarget must be a Function. Instead received %s.', finalMapStateToTarget\n      );\n\n    invariant(\n      isPlainObject(finalMapDispatchToTarget) || isFunction(finalMapDispatchToTarget),\n      'mapDispatchToTarget must be a plain Object or a Function. Instead received %s.', finalMapDispatchToTarget\n      );\n\n    let slice = getStateSlice(store.getState(), finalMapStateToTarget, false);\n    const isFactory = isFunction(slice);\n\n    if (isFactory) {\n      finalMapStateToTarget = slice;\n      slice = getStateSlice(store.getState(), finalMapStateToTarget);\n    }\n\n    const boundActionCreators = finalMapDispatchToTarget(store.dispatch);\n\n    return (target) => {\n\n      invariant(\n        isFunction(target) || isObject(target),\n        'The target parameter passed to connect must be a Function or a object.'\n        );\n\n      //Initial update\n      updateTarget(target, slice, boundActionCreators);\n\n      const unsubscribe = store.subscribe(() => {\n        const nextSlice = getStateSlice(store.getState(), finalMapStateToTarget);\n        if (!shallowEqual(slice, nextSlice)) {\n          updateTarget(target, nextSlice, boundActionCreators, slice);\n          slice = nextSlice;\n        }\n      });\n      return unsubscribe;\n    }\n\n  }\n}\n\nfunction updateTarget(target, StateSlice, dispatch, prevStateSlice) {\n  if(isFunction(target)) {\n    target(StateSlice, dispatch, prevStateSlice);\n  } else {\n    assign(target, StateSlice, dispatch);\n  }\n}\n\nfunction getStateSlice(state, mapStateToScope, shouldReturnObject = true) {\n  const slice = mapStateToScope(state);\n\n  if (shouldReturnObject) {\n    invariant(\n      isPlainObject(slice),\n      '`mapStateToScope` must return an object. Instead received %s.',\n      slice\n      );\n  } else {\n    invariant(\n      isPlainObject(slice) || isFunction(slice),\n      '`mapStateToScope` must return an object or a function. Instead received %s.',\n      slice\n      );\n  }\n\n  return slice;\n}\n","import debounce from 'lodash/debounce';\n\nexport default function digestMiddleware($rootScope, debounceConfig) {\n  let debouncedFunction = (expr) => {\n    $rootScope.$evalAsync(expr);\n  };\n  if(debounceConfig && debounceConfig.wait && debounceConfig.wait > 0) {\n    debouncedFunction = debounce(debouncedFunction, debounceConfig.wait, { maxWait: debounceConfig.maxWait });\n  }\n  return store => next => action => {\n    const res = next(action);\n    debouncedFunction(res);\n    return res;\n  };\n}\n","/**\n * middleware for the empty store that ng-redux uses when a external store is provided\n * Provides two cases:\n * 1. NGREDUX_PASSTHROUGH, where data is coming IN to the \"fake\" store\n * 2. all other, where actions are dispatched out, and proxied to the true store\n */\nexport default _providedStore => store => next => action => {\n  return action.type === '@@NGREDUX_PASSTHROUGH'\n    ? next(action)\n    : _providedStore.dispatch(action)\n}\n","export default function wrapStore(providedStore, ngReduxStore) {\n  providedStore.subscribe(() => {\n    let newState = providedStore.getState();\n    ngReduxStore.dispatch({\n      type: '@@NGREDUX_PASSTHROUGH',\n      payload: newState\n    });\n  });\n  providedStore.dispatch({ type: '@@NGREDUX_PASSTHROUGH_INIT' })\n}\n","import Connector from './connector';\nimport invariant from 'invariant';\nimport {createStore, applyMiddleware, compose, combineReducers} from 'redux';\nimport digestMiddleware from './digestMiddleware';\nimport providedStoreMiddleware from './providedStoreMiddleware';\nimport wrapStore from './storeWrapper';\n\nimport curry from 'lodash/curry';\nimport isFunction from 'lodash/isFunction';\nimport map from 'lodash/map';\n\nconst isArray = Array.isArray;\n\nconst typeIs = curry((type, val) => typeof val === type);\nconst isObject = typeIs('object');\nconst isString = typeIs('string');\nconst assign  = Object.assign;\n\nexport default function ngReduxProvider() {\n  let _reducer = undefined;\n  let _middlewares = undefined;\n  let _storeEnhancers = undefined;\n  let _initialState = undefined;\n  let _reducerIsObject = undefined;\n  let _providedStore = undefined;\n\n  this.provideStore = (store, middlewares = [], storeEnhancers) => {\n    _providedStore = store;\n    _reducer = (state, action) => action.payload;\n    _storeEnhancers = storeEnhancers;\n    _middlewares = [...middlewares, providedStoreMiddleware(store)];\n  }\n\n  this.createStoreWith = (reducer, middlewares, storeEnhancers, initialState) => {\n    invariant(\n      isFunction(reducer) || isObject(reducer),\n      'The reducer parameter passed to createStoreWith must be a Function or an Object. Instead received %s.',\n      typeof reducer\n    );\n\n    invariant(\n      !storeEnhancers || isArray(storeEnhancers),\n      'The storeEnhancers parameter passed to createStoreWith must be an Array. Instead received %s.',\n      typeof storeEnhancers\n    );\n\n    _reducer = reducer;\n    _reducerIsObject = isObject(reducer);\n    _storeEnhancers = storeEnhancers || [];\n    _middlewares = middlewares || [];\n    _initialState = initialState || {};\n  };\n\n  this.config = {\n    debounce: {\n      wait: undefined,\n      maxWait: undefined,\n    },\n  };\n\n  this.$get = ($injector) => {\n    const resolveMiddleware = middleware => isString(middleware)\n      ? $injector.get(middleware)\n      : middleware;\n\n    const resolvedMiddleware = map(_middlewares, resolveMiddleware);\n\n    const resolveStoreEnhancer = storeEnhancer => isString(storeEnhancer)\n      ? $injector.get(storeEnhancer)\n      : storeEnhancer;\n\n    const resolvedStoreEnhancer = map(_storeEnhancers, resolveStoreEnhancer);\n\n    if (_reducerIsObject) {\n      const getReducerKey = key => isString(_reducer[key])\n        ? $injector.get(_reducer[key])\n        : _reducer[key];\n\n      const resolveReducerKey = (result, key) => assign({}, result,\n        { [key]: getReducerKey(key) }\n      );\n\n      const reducersObj = Object\n        .keys(_reducer)\n        .reduce(resolveReducerKey, {});\n\n      _reducer = combineReducers(reducersObj);\n    }\n\n    // digestMiddleware needs to be the last one.\n    resolvedMiddleware.push(digestMiddleware($injector.get('$rootScope'), this.config.debounce));\n\n    // combine middleware into a store enhancer.\n    const middlewares = applyMiddleware(...resolvedMiddleware);\n\n    // compose enhancers with middleware and create store.\n    const store = createStore(_reducer, _initialState, compose(middlewares, ...resolvedStoreEnhancer));\n\n    // terradatum specific: we needed to add this lifecycle hook for middleware that requires \n    // that action be taken sometime after the middleware has been added to the redux store.\n    resolvedMiddleware.forEach(mw => {\n      if(mw.finalize) mw.finalize();\n    });\n\n    const mergedStore = assign({}, store, { connect: Connector(store) });\n\n    if (_providedStore) wrapStore(_providedStore, mergedStore);\n\n    return mergedStore;\n  };\n\n  this.$get.$inject = ['$injector'];\n}\n","import ngReduxProvider from './components/ngRedux';\n\nexport default angular.module('ngRedux', [])\n  .provider('$ngRedux', ngReduxProvider)\n  .name;"],"names":["shallowEqual","objA","objB","keysA","filter","k","keysB","length","hasOwn","Object","prototype","hasOwnProperty","i","call","wrapActionCreators","actionCreators","bindActionCreators","dispatch","assign","defaultMapStateToTarget","defaultMapDispatchToTarget","Connector","store","mapStateToTarget","mapDispatchToTarget","finalMapStateToTarget","finalMapDispatchToTarget","isPlainObject","isFunction","slice","getStateSlice","getState","isFactory","boundActionCreators","target","isObject","unsubscribe","subscribe","nextSlice","updateTarget","StateSlice","prevStateSlice","state","mapStateToScope","shouldReturnObject","digestMiddleware","$rootScope","debounceConfig","debouncedFunction","expr","$evalAsync","wait","debounce","maxWait","res","next","action","type","_providedStore","wrapStore","providedStore","ngReduxStore","newState","isArray","Array","typeIs","curry","val","isString","ngReduxProvider","_reducer","undefined","_middlewares","_storeEnhancers","_initialState","_reducerIsObject","provideStore","middlewares","storeEnhancers","payload","providedStoreMiddleware","createStoreWith","reducer","initialState","config","$get","$injector","resolveMiddleware","middleware","get","resolvedMiddleware","map","resolveStoreEnhancer","storeEnhancer","resolvedStoreEnhancer","getReducerKey","key","resolveReducerKey","result","reducersObj","reduce","combineReducers","push","applyMiddleware","createStore","compose","forEach","mw","finalize","mergedStore","connect","$inject","angular","module","provider","name"],"mappings":"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"}