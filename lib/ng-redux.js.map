{"version":3,"file":"ng-redux.js","sources":["../src/utils/shallowEqual.js","../src/utils/wrapActionCreators.js","../src/components/connector.js","../src/components/digestMiddleware.js","../src/components/providedStoreMiddleware.js","../src/components/storeWrapper.js","../src/components/ngRedux.js","../src/index.js"],"sourcesContent":[" export default function shallowEqual(objA, objB) {\n   if (objA === objB) {\n     return true;\n   }\n\n   /* $$hashKey is added by angular when using ng-repeat, we ignore that*/\n   var keysA = Object.keys(objA).filter(k => k !== '$$hashKey');\n   var keysB = Object.keys(objB).filter(k => k !== '$$hashKey');\n\n   if (keysA.length !== keysB.length) {\n     return false;\n   }\n\n   // Test for A's keys different from B.\n   var hasOwn = Object.prototype.hasOwnProperty;\n   for (let i = 0; i < keysA.length; i++) {\n     if (!hasOwn.call(objB, keysA[i]) ||\n       objA[keysA[i]] !== objB[keysA[i]]) {\n       return false;\n     }\n   }\n\n   return true;\n }","import { bindActionCreators } from 'redux';\n\nexport default function wrapActionCreators(actionCreators) {\n  return dispatch => bindActionCreators(actionCreators, dispatch);\n}\n","import shallowEqual from '../utils/shallowEqual';\nimport wrapActionCreators from '../utils/wrapActionCreators';\nimport invariant from 'invariant';\n\nimport isPlainObject from 'lodash/isPlainObject';\nimport isFunction from 'lodash/isFunction';\nimport isObject from 'lodash/isObject';\n\nconst assign = Object.assign;\nconst defaultMapStateToTarget = () => ({});\nconst defaultMapDispatchToTarget = dispatch => ({dispatch});\n\nexport default function Connector(store) {\n  return (mapStateToTarget, mapDispatchToTarget) => {\n\n    let finalMapStateToTarget = mapStateToTarget || defaultMapStateToTarget;\n\n    const finalMapDispatchToTarget = isObject(mapDispatchToTarget) && !isFunction(mapDispatchToTarget) ?\n      wrapActionCreators(mapDispatchToTarget) :\n      mapDispatchToTarget || defaultMapDispatchToTarget;\n\n    invariant(\n      isFunction(finalMapStateToTarget),\n      'mapStateToTarget must be a Function. Instead received %s.', finalMapStateToTarget\n      );\n\n    invariant(\n      isObject(finalMapDispatchToTarget) || isFunction(finalMapDispatchToTarget),\n      'mapDispatchToTarget must be a plain Object or a Function. Instead received %s.', finalMapDispatchToTarget\n      );\n\n    let slice = getStateSlice(store.getState(), finalMapStateToTarget, false);\n    const isFactory = isFunction(slice);\n\n    if (isFactory) {\n      finalMapStateToTarget = slice;\n      slice = getStateSlice(store.getState(), finalMapStateToTarget);\n    }\n\n    const boundActionCreators = finalMapDispatchToTarget(store.dispatch);\n\n    return (target) => {\n\n      invariant(\n        isFunction(target) || isObject(target),\n        'The target parameter passed to connect must be a Function or a object.'\n        );\n\n      //Initial update\n      updateTarget(target, slice, boundActionCreators);\n\n      const unsubscribe = store.subscribe(() => {\n        const nextSlice = getStateSlice(store.getState(), finalMapStateToTarget);\n        if (!shallowEqual(slice, nextSlice)) {\n          updateTarget(target, nextSlice, boundActionCreators, slice);\n          slice = nextSlice;\n        }\n      });\n      return unsubscribe;\n    }\n\n  }\n}\n\nfunction updateTarget(target, StateSlice, dispatch, prevStateSlice) {\n  if(isFunction(target)) {\n    target(StateSlice, dispatch, prevStateSlice);\n  } else {\n    assign(target, StateSlice, dispatch);\n  }\n}\n\nfunction getStateSlice(state, mapStateToScope, shouldReturnObject = true) {\n  const slice = mapStateToScope(state);\n\n  if (shouldReturnObject) {\n    invariant(\n      isPlainObject(slice),\n      '`mapStateToScope` must return an object. Instead received %s.',\n      slice\n      );\n  } else {\n    invariant(\n      isPlainObject(slice) || isFunction(slice),\n      '`mapStateToScope` must return an object or a function. Instead received %s.',\n      slice\n      );\n  }\n\n  return slice;\n}\n","import debounce from 'lodash/debounce';\n\nexport default function digestMiddleware($rootScope, debounceConfig) {\n  let debouncedFunction = (expr) => {\n    $rootScope.$evalAsync(expr);\n  };\n  if(debounceConfig && debounceConfig.wait && debounceConfig.wait > 0) {\n    debouncedFunction = debounce(debouncedFunction, debounceConfig.wait, { maxWait: debounceConfig.maxWait });\n  }\n  return store => next => action => {\n    const res = next(action);\n    debouncedFunction(res);\n    return res;\n  };\n}\n","/**\n * middleware for the empty store that ng-redux uses when a external store is provided\n * Provides two cases:\n * 1. NGREDUX_PASSTHROUGH, where data is coming IN to the \"fake\" store\n * 2. all other, where actions are dispatched out, and proxied to the true store\n */\nexport default _providedStore => store => next => action => {\n  return action.type === '@@NGREDUX_PASSTHROUGH'\n    ? next(action)\n    : _providedStore.dispatch(action)\n}\n","export default function wrapStore(providedStore, ngReduxStore) {\n  providedStore.subscribe(() => {\n    let newState = providedStore.getState();\n    ngReduxStore.dispatch({\n      type: '@@NGREDUX_PASSTHROUGH',\n      payload: newState\n    });\n  });\n  providedStore.dispatch({ type: '@@NGREDUX_PASSTHROUGH_INIT' })\n}\n","import Connector from './connector';\nimport invariant from 'invariant';\nimport {createStore, applyMiddleware, compose, combineReducers} from 'redux';\nimport digestMiddleware from './digestMiddleware';\nimport providedStoreMiddleware from './providedStoreMiddleware';\nimport wrapStore from './storeWrapper';\n\nimport curry from 'lodash/curry';\nimport isFunction from 'lodash/isFunction';\nimport map from 'lodash/map';\n\nconst isArray = Array.isArray;\n\nconst typeIs = curry((type, val) => typeof val === type);\nconst isObject = typeIs('object');\nconst isString = typeIs('string');\nconst assign  = Object.assign;\n\nexport default function ngReduxProvider() {\n  let _reducer = undefined;\n  let _middlewares = undefined;\n  let _storeEnhancers = undefined;\n  let _initialState = undefined;\n  let _reducerIsObject = undefined;\n  let _providedStore = undefined;\n  let _storeCreator = undefined;\n\n  this.provideStore = (store, middlewares = [], storeEnhancers) => {\n    _providedStore = store;\n    _reducer = (state, action) => action.payload;\n    _storeEnhancers = storeEnhancers;\n    _middlewares = [...middlewares, providedStoreMiddleware(store)];\n  }\n\n  this.createStore = (storeCreator) => {\n    _storeCreator = storeCreator\n  };\n\n  this.createStoreWith = (reducer, middlewares, storeEnhancers, initialState) => {\n    invariant(\n      isFunction(reducer) || isObject(reducer),\n      'The reducer parameter passed to createStoreWith must be a Function or an Object. Instead received %s.',\n      typeof reducer\n    );\n\n    invariant(\n      !storeEnhancers || isArray(storeEnhancers),\n      'The storeEnhancers parameter passed to createStoreWith must be an Array. Instead received %s.',\n      typeof storeEnhancers\n    );\n\n    _reducer = reducer;\n    _reducerIsObject = isObject(reducer);\n    _storeEnhancers = storeEnhancers || [];\n    _middlewares = middlewares || [];\n    _initialState = initialState || {};\n  };\n\n  this.config = {\n    debounce: {\n      wait: undefined,\n      maxWait: undefined,\n    },\n  };\n\n  this.$get = ($injector) => {\n    const resolveMiddleware = middleware => isString(middleware)\n      ? $injector.get(middleware)\n      : middleware;\n\n    const resolvedMiddleware = map(_middlewares, resolveMiddleware);\n\n    const resolveStoreEnhancer = storeEnhancer => isString(storeEnhancer)\n      ? $injector.get(storeEnhancer)\n      : storeEnhancer;\n\n    const resolvedStoreEnhancer = map(_storeEnhancers, resolveStoreEnhancer);\n\n    if (_reducerIsObject) {\n      const getReducerKey = key => isString(_reducer[key])\n        ? $injector.get(_reducer[key])\n        : _reducer[key];\n\n      const resolveReducerKey = (result, key) => assign({}, result,\n        { [key]: getReducerKey(key) }\n      );\n\n      const reducersObj = Object\n        .keys(_reducer)\n        .reduce(resolveReducerKey, {});\n\n      _reducer = combineReducers(reducersObj);\n    }\n\n    // digestMiddleware needs to be the last one.\n    resolvedMiddleware.push(digestMiddleware($injector.get('$rootScope'), this.config.debounce));\n\n    let store;\n    if(_storeCreator) {\n      store = _storeCreator(resolvedMiddleware, resolvedStoreEnhancer);\n    } else {\n      // combine middleware into a store enhancer.\n      const middlewares = applyMiddleware(...resolvedMiddleware);\n      // compose enhancers with middleware and create store.\n      store = createStore(_reducer, _initialState, compose(middlewares, ...resolvedStoreEnhancer));\n    }\n\n    // terradatum specific: we needed to add this lifecycle hook for middleware that requires \n    // that action be taken sometime after the middleware has been added to the redux store.\n    resolvedMiddleware.forEach(mw => {\n      if(mw.finalize) mw.finalize();\n    });\n\n    const mergedStore = assign({}, store, { connect: Connector(store) });\n\n    if (_providedStore) wrapStore(_providedStore, mergedStore);\n\n    return mergedStore;\n  };\n\n  this.$get.$inject = ['$injector'];\n}\n","import ngReduxProvider from './components/ngRedux';\n\nexport default angular.module('ngRedux', [])\n  .provider('$ngRedux', ngReduxProvider)\n  .name;"],"names":["shallowEqual","objA","objB","keysA","filter","k","keysB","length","hasOwn","Object","prototype","hasOwnProperty","i","call","wrapActionCreators","actionCreators","bindActionCreators","dispatch","assign","defaultMapStateToTarget","defaultMapDispatchToTarget","Connector","store","mapStateToTarget","mapDispatchToTarget","finalMapStateToTarget","finalMapDispatchToTarget","isObject","isFunction","slice","getStateSlice","getState","isFactory","boundActionCreators","target","unsubscribe","subscribe","nextSlice","updateTarget","StateSlice","prevStateSlice","state","mapStateToScope","shouldReturnObject","isPlainObject","digestMiddleware","$rootScope","debounceConfig","debouncedFunction","expr","$evalAsync","wait","debounce","maxWait","res","next","action","type","_providedStore","wrapStore","providedStore","ngReduxStore","newState","isArray","Array","typeIs","curry","val","isString","ngReduxProvider","_reducer","undefined","_middlewares","_storeEnhancers","_initialState","_reducerIsObject","_storeCreator","provideStore","middlewares","storeEnhancers","payload","providedStoreMiddleware","createStore","storeCreator","createStoreWith","reducer","initialState","config","$get","$injector","resolveMiddleware","middleware","get","resolvedMiddleware","map","resolveStoreEnhancer","storeEnhancer","resolvedStoreEnhancer","getReducerKey","key","resolveReducerKey","result","reducersObj","reduce","combineReducers","push","applyMiddleware","compose","forEach","mw","finalize","mergedStore","connect","$inject","angular","module","provider","name"],"mappings":"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"}